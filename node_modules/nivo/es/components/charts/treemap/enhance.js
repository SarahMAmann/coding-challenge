var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/*
 * This file is part of the nivo project.
 *
 * Copyright 2016-present, RaphaÃ«l Benitte.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { treemap as d3Treemap } from 'd3-hierarchy';
import cloneDeep from 'lodash/cloneDeep';
import compose from 'recompose/compose';
import defaultProps from 'recompose/defaultProps';
import withPropsOnChange from 'recompose/withPropsOnChange';
import pure from 'recompose/pure';
import { withHierarchy, withDimensions, withTheme, withMotion, withColors } from '../../../hocs';
import { getAccessorFor, getLabelGenerator } from '../../../lib/propertiesConverters';
import { treeMapTileFromProp } from '../../../props';
import { getInheritedColorGenerator } from '../../../lib/colors';
import { computeNodePath } from '../../../lib/hierarchy';
import { bindDefs } from '../../../lib/defs';
import * as props from './props';

var commonEnhancers = [withHierarchy(), withDimensions(), withColors({ defaultColorBy: 'depth' }), withTheme(), withMotion(), withPropsOnChange(['identity'], function (_ref) {
    var identity = _ref.identity;
    return {
        getIdentity: getAccessorFor(identity)
    };
}), withPropsOnChange(['borderColor'], function (_ref2) {
    var borderColor = _ref2.borderColor;
    return {
        getBorderColor: getInheritedColorGenerator(borderColor)
    };
}), withPropsOnChange(['label', 'labelFormat'], function (_ref3) {
    var label = _ref3.label,
        labelFormat = _ref3.labelFormat;
    return {
        getLabel: getLabelGenerator(label, labelFormat)
    };
}), withPropsOnChange(['labelTextColor'], function (_ref4) {
    var labelTextColor = _ref4.labelTextColor;
    return {
        getLabelTextColor: getInheritedColorGenerator(labelTextColor)
    };
}), withPropsOnChange(['width', 'height', 'tile', 'innerPadding', 'outerPadding'], function (_ref5) {
    var width = _ref5.width,
        height = _ref5.height,
        tile = _ref5.tile,
        innerPadding = _ref5.innerPadding,
        outerPadding = _ref5.outerPadding;
    return {
        treemap: d3Treemap().size([width, height]).tile(treeMapTileFromProp(tile)).round(true).paddingInner(innerPadding).paddingOuter(outerPadding)
    };
}), withPropsOnChange(['root', 'treemap', 'leavesOnly', 'getIdentity', 'getColor'], function (_ref6) {
    var _root = _ref6.root,
        treemap = _ref6.treemap,
        leavesOnly = _ref6.leavesOnly,
        getIdentity = _ref6.getIdentity,
        getColor = _ref6.getColor;

    var root = cloneDeep(_root);

    treemap(root);

    var nodes = leavesOnly ? root.leaves() : root.descendants();
    nodes = nodes.map(function (d) {
        d.path = computeNodePath(d, getIdentity);

        d.nodeHeight = d.height;

        d.x = d.x0;
        d.y = d.y0;
        d.width = d.x1 - d.x0;
        d.height = d.y1 - d.y0;
        d.data.color = d.color = getColor(_extends({}, d.data, { depth: d.depth }));

        d.data.id = d.id = getIdentity(d.data);
        d.data.value = d.value;

        return d;
    });

    return { nodes: nodes };
}), withPropsOnChange(['enableLabel', 'nodes', 'getLabel', 'labelSkipSize'], function (_ref7) {
    var enableLabel = _ref7.enableLabel,
        nodes = _ref7.nodes,
        getLabel = _ref7.getLabel,
        labelSkipSize = _ref7.labelSkipSize;

    if (!enableLabel) return;

    var nodesWithLabel = nodes.map(function (node) {
        if (node.nodeHeight > 0 || labelSkipSize !== 0 && Math.min(node.width, node.height) <= labelSkipSize) return node;
        return _extends({}, node, { label: getLabel(node.data) });
    });

    return { nodes: nodesWithLabel };
})];

var svgEnhancers = [withPropsOnChange(['nodes', 'defs', 'fill'], function (_ref8) {
    var nodes = _ref8.nodes,
        defs = _ref8.defs,
        fill = _ref8.fill;

    return {
        defs: bindDefs(defs, nodes, fill, { targetKey: 'fill' })
    };
})];

export default (function (Component) {
    var implPropTypes = props[Component.displayName + 'PropTypes'];
    var implDefaultProps = props[Component.displayName + 'DefaultProps'];

    Component.propTypes = implPropTypes;

    switch (Component.displayName) {
        case 'TreeMap':
        case 'TreeMapPlaceholders':
            return compose.apply(undefined, [defaultProps(implDefaultProps)].concat(commonEnhancers, svgEnhancers, [withMotion(), pure]))(Component);

        case 'TreeMapHtml':
            return compose.apply(undefined, [defaultProps(implDefaultProps)].concat(commonEnhancers, [withMotion(), pure]))(Component);

        case 'TreeMapCanvas':
            return compose.apply(undefined, [defaultProps(implDefaultProps)].concat(commonEnhancers, [pure]))(Component);
    }

    return Component;
});