var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/*
 * This file is part of the nivo project.
 *
 * Copyright 2016-present, RaphaÃ«l Benitte.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { pack } from 'd3-hierarchy';
import compose from 'recompose/compose';
import defaultProps from 'recompose/defaultProps';
import withPropsOnChange from 'recompose/withPropsOnChange';
import withStateHandlers from 'recompose/withStateHandlers';
import pure from 'recompose/pure';
import { withHierarchy, withDimensions, withTheme, withMotion, withColors } from '../../../hocs';
import { getAccessorFor, getLabelGenerator } from '../../../lib/propertiesConverters';
import { getInheritedColorGenerator } from '../../../lib/colors';
import { bindDefs } from '../../../lib/defs';
import { computeNodes, computeZoom } from '../../../lib/charts/bubble';
import * as props from './props';

var commonEnhancers = [withHierarchy(), withDimensions(), withTheme(), withColors({ defaultColorBy: 'depth' }), withPropsOnChange(['width', 'height', 'padding'], function (_ref) {
    var width = _ref.width,
        height = _ref.height,
        padding = _ref.padding;
    return {
        pack: pack().size([width, height]).padding(padding)
    };
}), withPropsOnChange(['identity'], function (_ref2) {
    var identity = _ref2.identity;
    return {
        getIdentity: getAccessorFor(identity)
    };
}),

// border
withPropsOnChange(['borderColor'], function (_ref3) {
    var borderColor = _ref3.borderColor;
    return {
        getBorderColor: getInheritedColorGenerator(borderColor)
    };
}),

// labels
withPropsOnChange(['label', 'labelFormat'], function (_ref4) {
    var label = _ref4.label,
        labelFormat = _ref4.labelFormat;
    return {
        getLabel: getLabelGenerator(label, labelFormat)
    };
}), withPropsOnChange(['labelTextColor'], function (_ref5) {
    var labelTextColor = _ref5.labelTextColor;
    return {
        getLabelTextColor: getInheritedColorGenerator(labelTextColor)
    };
}),

// zoom
withStateHandlers(function (_ref6) {
    var _ref6$currentNodePath = _ref6.currentNodePath,
        currentNodePath = _ref6$currentNodePath === undefined ? null : _ref6$currentNodePath;
    return {
        currentNodePath: currentNodePath
    };
}, {
    zoomToNode: function zoomToNode(_ref7) {
        var currentNodePath = _ref7.currentNodePath;
        return function (path) {
            if (path === currentNodePath) return { currentNodePath: null };
            return { currentNodePath: path };
        };
    }
}), withPropsOnChange(['root', 'pack', 'leavesOnly', 'getIdentity', 'getColor'], function (_ref8) {
    var root = _ref8.root,
        pack = _ref8.pack,
        leavesOnly = _ref8.leavesOnly,
        getIdentity = _ref8.getIdentity,
        getColor = _ref8.getColor;

    var nodes = computeNodes({ root: root, pack: pack, leavesOnly: leavesOnly, getIdentity: getIdentity, getColor: getColor });

    return { nodes: nodes };
}), withPropsOnChange(['enableLabel', 'nodes', 'getLabel', 'labelSkipRadius'], function (_ref9) {
    var enableLabel = _ref9.enableLabel,
        nodes = _ref9.nodes,
        getLabel = _ref9.getLabel,
        labelSkipRadius = _ref9.labelSkipRadius;

    if (!enableLabel) return;
    var nodesWithLabel = nodes.map(function (node) {
        if (node.height !== 0 || labelSkipRadius > 0 && node.r < labelSkipRadius) return node;
        return _extends({}, node, { label: getLabel(node) });
    });

    return { nodes: nodesWithLabel };
}), withPropsOnChange(['nodes', 'isZoomable', 'currentNodePath'], function (_ref10) {
    var nodes = _ref10.nodes,
        isZoomable = _ref10.isZoomable,
        currentNodePath = _ref10.currentNodePath,
        width = _ref10.width,
        height = _ref10.height;

    if (currentNodePath && isZoomable) {
        return {
            nodes: computeZoom(nodes, currentNodePath, width, height)
        };
    }
})];

var svgEnhancers = [withPropsOnChange(['nodes', 'defs', 'fill'], function (_ref11) {
    var nodes = _ref11.nodes,
        defs = _ref11.defs,
        fill = _ref11.fill;

    return {
        defs: bindDefs(defs, nodes, fill, { targetKey: 'fill' })
    };
})];

export default (function (Component) {
    var implPropTypes = props[Component.displayName + 'PropTypes'];
    var implDefaultProps = props[Component.displayName + 'DefaultProps'];

    Component.propTypes = implPropTypes;

    switch (Component.displayName) {
        case 'Bubble':
            return compose.apply(undefined, [defaultProps(implDefaultProps)].concat(commonEnhancers, svgEnhancers, [withMotion(), pure]))(Component);

        case 'BubbleHtml':
            return compose.apply(undefined, [defaultProps(implDefaultProps)].concat(commonEnhancers, [withMotion(), pure]))(Component);

        case 'BubbleCanvas':
            return compose.apply(undefined, [defaultProps(implDefaultProps)].concat(commonEnhancers, [pure]))(Component);
    }

    return Component;
});