var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/*
 * This file is part of the nivo project.
 *
 * Copyright 2016-present, RaphaÃ«l Benitte.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { computeNodePath } from '../../hierarchy';

export var computeNodes = function computeNodes(_ref) {
    var root = _ref.root,
        pack = _ref.pack,
        leavesOnly = _ref.leavesOnly,
        getIdentity = _ref.getIdentity,
        getColor = _ref.getColor;

    // assign a unique id depending on node path to each node
    root.each(function (node) {
        node.id = getIdentity(node.data);
        node.path = computeNodePath(node, getIdentity);
    });

    pack(root);

    var nodes = leavesOnly ? root.leaves() : root.descendants();
    nodes = nodes.map(function (node) {
        node.color = getColor(_extends({}, node.data, { depth: node.depth }));
        node.label = false;

        return node;
    });

    return nodes;
};

export var computeZoom = function computeZoom(nodes, currentNodePath, width, height) {
    var currentNode = nodes.find(function (_ref2) {
        var path = _ref2.path;
        return path === currentNodePath;
    });

    if (!currentNode) return nodes;

    var ratio = Math.min(width, height) / (currentNode.r * 2);
    var offsetX = width / 2 - currentNode.x * ratio;
    var offsetY = height / 2 - currentNode.y * ratio;

    return nodes.map(function (node) {
        return _extends({}, node, {
            r: node.r * ratio,
            x: node.x * ratio + offsetX,
            y: node.y * ratio + offsetY
        });
    });
};