'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _polar = require('../../../lib/polar');

var _interactivity = require('../../../lib/interactivity');

var _Container = require('../Container');

var _Container2 = _interopRequireDefault(_Container);

var _enhance = require('./enhance');

var _enhance2 = _interopRequireDefault(_enhance);

var _TreeMapNodeTooltip = require('./TreeMapNodeTooltip');

var _TreeMapNodeTooltip2 = _interopRequireDefault(_TreeMapNodeTooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This file is part of the nivo project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016-present, RaphaÃ«l Benitte.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * For the full copyright and license information, please view the LICENSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * file that was distributed with this source code.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var findNodeUnderCursor = function findNodeUnderCursor(nodes, margin, x, y) {
    return nodes.find(function (node) {
        return (0, _interactivity.isCursorInRect)(node.x + margin.left, node.y + margin.top, node.width, node.height, x, y);
    });
};

var TreeMapCanvas = function (_Component) {
    _inherits(TreeMapCanvas, _Component);

    function TreeMapCanvas() {
        var _temp, _this, _ret;

        _classCallCheck(this, TreeMapCanvas);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.handleMouseHover = function (showTooltip, hideTooltip) {
            return function (event) {
                var _this$props = _this.props,
                    isInteractive = _this$props.isInteractive,
                    nodes = _this$props.nodes,
                    margin = _this$props.margin,
                    theme = _this$props.theme;


                if (!isInteractive) return;

                var _getRelativeCursor = (0, _interactivity.getRelativeCursor)(_this.surface, event),
                    x = _getRelativeCursor[0],
                    y = _getRelativeCursor[1];

                var node = findNodeUnderCursor(nodes, margin, x, y);

                if (node !== undefined) {
                    showTooltip(_react2.default.createElement(_TreeMapNodeTooltip2.default, { node: node, theme: theme }), event);
                } else {
                    hideTooltip();
                }
            };
        }, _this.handleMouseLeave = function (hideTooltip) {
            return function () {
                hideTooltip();
            };
        }, _this.handleClick = function (event) {
            var _this$props2 = _this.props,
                isInteractive = _this$props2.isInteractive,
                nodes = _this$props2.nodes,
                margin = _this$props2.margin,
                onClick = _this$props2.onClick;


            if (!isInteractive) return;

            var _getRelativeCursor2 = (0, _interactivity.getRelativeCursor)(_this.surface, event),
                x = _getRelativeCursor2[0],
                y = _getRelativeCursor2[1];

            var node = findNodeUnderCursor(nodes, margin, x, y);
            if (node !== undefined) onClick(node, event);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    TreeMapCanvas.prototype.componentDidMount = function componentDidMount() {
        this.ctx = this.surface.getContext('2d');
        this.draw(this.props);
    };

    TreeMapCanvas.prototype.componentDidUpdate = function componentDidUpdate() {
        this.ctx = this.surface.getContext('2d');
        this.draw(this.props);
    };

    TreeMapCanvas.prototype.draw = function draw(props) {
        var _this2 = this;

        var nodes = props.nodes,
            pixelRatio = props.pixelRatio,
            margin = props.margin,
            outerWidth = props.outerWidth,
            outerHeight = props.outerHeight,
            borderWidth = props.borderWidth,
            getBorderColor = props.getBorderColor,
            enableLabel = props.enableLabel,
            getLabelTextColor = props.getLabelTextColor,
            orientLabel = props.orientLabel;


        this.surface.width = outerWidth * pixelRatio;
        this.surface.height = outerHeight * pixelRatio;

        this.ctx.scale(pixelRatio, pixelRatio);
        this.ctx.clearRect(0, 0, outerWidth, outerHeight);
        this.ctx.translate(margin.left, margin.top);

        nodes.forEach(function (node) {
            _this2.ctx.fillStyle = node.color;
            _this2.ctx.fillRect(node.x, node.y, node.width, node.height);

            if (borderWidth > 0) {
                _this2.ctx.strokeStyle = getBorderColor(node);
                _this2.ctx.lineWidth = borderWidth;
                _this2.ctx.strokeRect(node.x, node.y, node.width, node.height);
            }
        });

        if (enableLabel) {
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            // draw labels on top
            nodes.filter(function (_ref) {
                var label = _ref.label;
                return label !== undefined;
            }).forEach(function (node) {
                var labelTextColor = getLabelTextColor(node);

                var rotate = orientLabel && node.height > node.width;

                _this2.ctx.save();
                _this2.ctx.translate(node.x + node.width / 2, node.y + node.height / 2);
                _this2.ctx.rotate((0, _polar.degreesToRadians)(rotate ? -90 : 0));

                _this2.ctx.fillStyle = labelTextColor;
                _this2.ctx.fillText(node.label, 0, 0);

                _this2.ctx.restore();
            });
        }
    };

    TreeMapCanvas.prototype.render = function render() {
        var _this3 = this;

        var _props = this.props,
            outerWidth = _props.outerWidth,
            outerHeight = _props.outerHeight,
            pixelRatio = _props.pixelRatio,
            isInteractive = _props.isInteractive,
            theme = _props.theme;


        return _react2.default.createElement(
            _Container2.default,
            { isInteractive: isInteractive, theme: theme },
            function (_ref2) {
                var showTooltip = _ref2.showTooltip,
                    hideTooltip = _ref2.hideTooltip;
                return _react2.default.createElement('canvas', {
                    ref: function ref(surface) {
                        _this3.surface = surface;
                    },
                    width: outerWidth * pixelRatio,
                    height: outerHeight * pixelRatio,
                    style: {
                        width: outerWidth,
                        height: outerHeight
                    },
                    onMouseEnter: _this3.handleMouseHover(showTooltip, hideTooltip),
                    onMouseMove: _this3.handleMouseHover(showTooltip, hideTooltip),
                    onMouseLeave: _this3.handleMouseLeave(hideTooltip),
                    onClick: _this3.handleClick
                });
            }
        );
    };

    return TreeMapCanvas;
}(_react.Component);

TreeMapCanvas.displayName = 'TreeMapCanvas';

exports.default = (0, _enhance2.default)(TreeMapCanvas);